<!DOCTYPE html>
<html lang="pt-pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Relatório LABSI</title>
    <link rel="stylesheet" href="styles/style.css">
</head>
<body>
    <header>
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <div>
                <h1>MAPEAMENTO 360º</h1>
                <p>Autores:</p> 
                
                    <p>Gonçalo Melo 1211710 </p>
                <p>Sandro Gomes 1221717</p>
            </div>
            <div>
                <img src="images/logo.jpeg" alt="Logo" style="width: 130px; height: 100px;">
            </div>
        </div>
    </header>

    <nav>
        <a href="#introducao">Introdução</a>
        <a href="#arquitetura">Arquitetura</a>
        <a href="#hardware">Hardware</a>
        <a href="#software">Software</a>
        <a href="#resultados">Resultados</a>
        <a href="#conclusoes">Conclusões</a>
        <a href="#referencias">Referências</a>
    </nav>
    <section id="introducao">
        <h2>Introdução</h2>
        <p>Este projeto é submetido à unidade curricular de Laboratório de Sistemas (LABSI), no âmbito da Licenciatura em Engenharia Eletrotécnica e de Computadores (LEEC), do Departamento de Engenharia Eletrotécnica (DEE), ministrada pelo Instituto Superior de Engenharia do Porto (ISEP). O presente documento consiste num relatório sobre o projeto “Mapeamento 360º”. 
            No âmbito da licenciatura em Engenharia Eletrotécnica e de Computadores e de um ponto de vista técnico, considerou-se apropriada a elaboração de um relatório onde serão abordadas as temáticas do projeto proposto, assim como a sua aplicabilidade prática. Este relatório descreve o desenvolvimento de um sistema de mapeamento 2D/3D baseado em hardware acessível e controlado por um microcontrolador, com aplicação em áreas como robótica e automação.
            A metodologia utilizada neste trabalho baseou-se principalmente nos conteúdos lecionados ao longo do curso, complementados por uma revisão de literatura. </p>

            <h3>Problema e Motivação</h3>
            <p>O mapeamento 2D/3D é uma funcionalidade indispensável em áreas como a robótica e a automação. Contudo, as soluções disponíveis são, muitas vezes, dispendiosas e complexas, dificultando a sua aplicação em contextos educativos e experimentais. Este projeto surge como resposta a esta limitação, propondo o desenvolvimento de um sistema acessível e eficaz que combina componentes de baixo custo. O objetivo é disponibilizar uma ferramenta prática para a captura e visualização de dados em tempo real, promovendo a inovação e a aprendizagem no âmbito académico.</p>

            <p><p>Ao analisar as soluções de mapeamento 2D/3D presentes no mercado, revelou-se uma clara distinção entre sistemas industriais e soluções de baixo custo. Produtos como o <strong>Leica RTC360</strong>, o <strong>RPLIDAR A1M8-R6</strong> e o <strong>TiM571-2050101</strong> oferecem excelente precisão, alcance e robustez, mas apresentam custos elevados e são projetados para ambientes profissionais, não sendo viáveis para projetos académicos com orçamento restrito.</p>

            <h3>Comparação de Produtos Similares</h3>
            <h4>Tabela 1 - Projetos Similares </h4>
            <table>
                <thead>
                    <tr>
                        <th>Produto</th>
                        <th>Leica RTC360</th>
                        <th>RPLIDAR A1M8-R6</th>
                        <th>TiM571-2050101</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Peso</td>
                        <td>5,35Kg</td>
                        <td>0,17Kg</td>
                        <td>0,25Kg</td>
                    </tr>
                    <tr>
                        <td>Alimentação</td>
                        <td>15V</td>
                        <td>5V</td>
                        <td>9V</td>
                    </tr>
                    <tr>
                        <td>Precisão</td>
                        <td>1,9mm até 10m</td>
                        <td>99% até 3m</td>
                        <td>90% até 8m</td>
                    </tr>
                    <tr>
                        <td>Conectividade</td>
                        <td>Wireless</td>
                        <td>UART Serial</td>
                        <td>Ethernet/USB</td>
                    </tr>
                    <tr>
                        <td>Alcance</td>
                        <td>0,5m - 130m</td>
                        <td>0,15m - 12m</td>
                        <td>0,05m - 25m</td>
                    </tr>
                    <tr>
                        <td>Resolução angular</td>
                        <td>3/6/12mm</td>
                        <td>1% até 12m</td>
                        <td>0,33º</td>
                    </tr>
                    <tr>
                        <td>Taxa de amostragem</td>
                        <td>2000000pts/s</td>
                        <td>8kHz</td>
                        <td>15Hz</td>
                    </tr>
                    <tr>
                        <td>Ângulo scan</td>
                        <td>360º horizontal 300º vertical</td>
                        <td>360º</td>
                        <td>270º</td>
                    </tr>
                    <tr>
                        <td>Rotação</td>
                        <td>60s scan completo</td>
                        <td>5.5Hz</td>
                        <td>67ms</td>
                    </tr>
                    <tr>
                        <td>Temperatura</td>
                        <td>-5º - 40ºC</td>
                        <td>0º - 40ºC</td>
                        <td>-25º - 50ºC</td>
                    </tr>
                    <tr>
                        <td>Consumo</td>
                        <td></td>
                        <td>0,5W</td>
                        <td>4W</td>
                    </tr>
                </tbody>
            </table>
    
            <p>Para desenvolver um sistema de mapeamento 2D/3D, utilizando sensores de distância e motores de precisão controlados por um microcontrolador. O sistema deverá captar dados do espaço envolvente e transmiti-los para um computador, onde serão apresentados numa interface gráfica em tempo real. Este projeto visa criar uma solução acessível e eficiente, com foco em contextos educativos e experimentais.</p>
        


    </section>


    <section id="arquitetura">
        <h2>Arquitetura</h2>
<h3>Arquitetura Detalhada</h3>

        <figure>
            <img src="images/Diagrama_blocos.png" alt="Diagrama de blocos">
            <figcaption>Diagrama de blocos</figcaption>
        </figure>

        <p>O sistema é composto por quatro subsistemas principais: microcontrolador, sensor de distância, mecanismo de rotação (dois motores) e interface gráfica no PC. O diagrama de blocos abaixo ilustra as interações entre os subsistemas.
            Este diagrama é composto por detetores (entradas) e atuadores (saídas). 
            A seta com duplo sentido (entrada e saída) representa a troca de informações que o microcontrolador realiza com o PC.
            </p>

        <h3>Interfaces e subsistemas</h3>
        
        <ul>
            <li><strong>Microcontrolador ↔ Sensor de Distância:</strong> Comunicação via sinal digital (TRIGGER/ECHO).</li>
            <li><strong>Microcontrolador ↔ Mecanismos de Rotação:</strong> Controlo via pulsos LOW/HIGH, ajustando a posição do motor.</li>
            <li><strong>Microcontrolador ↔ PC:</strong> Comunicação serial UART para envio de dados processados.</li>
        </ul>

        <h3>Descrição dos subsistemas</h3>
        
        
            <ul>
                <li>
                    <strong>Microcontrolador:</strong>
                    <p><strong>Função:</strong> Atua como a unidade central de processamento do sistema. Recebe os dados do sensor de distância, interpreta as informações e controla o mecanismo de rotação do sensor. Além disso, gere a comunicação com o PC para envio dos dados mapeados.</p>
                </li>
                <li>
                    <strong>Sensor de Distância:</strong>
                    <p><strong>Função:</strong> Realiza medições precisas da distância entre o sistema e os obstáculos circundantes. Este subsistema é responsável por fornecer os dados essenciais para o mapeamento do ambiente.</p>
                </li>
                <li>
                    <strong>Mecanismo de Rotação:</strong>
                    <p><strong>Função:</strong> Permite o movimento rotacional do sensor de distância, cobrindo 360 graus. Este mecanismo garante a coleta de dados em todas as direções, sendo fundamental para o mapeamento completo da área envolvente.</p>
                </li>
                <li>
                    <strong>PC (Interface Gráfica):</strong>
                    <p><strong>Função:</strong> Exibe os dados processados pelo microcontrolador em formato visual, apresentando um mapa 2D ou 3D do ambiente. A interface gráfica é atualizada em tempo real, permitindo ao utilizador acompanhar o progresso da digitalização e analisar os dados obtidos de forma intuitiva.</p>
                </li>
                </ul>

        <h3>Protocolo USART</h3>
    <ul>
        <p>
        O protocolo USART (Universal Synchronous/Asynchronous Receiver Transmitter) é uma interface de comunicação serial amplamente utilizada para transmitir e receber dados. Ele suporta dois modos de operação: assíncrono e síncrono.
    </p>

    <h4>Modo Assíncrono (UART)</h4>
    <p>
        No modo assíncrono, não há sincronização de clock entre o transmissor e o recetor. Em vez disso, ambos os dispositivos utilizam uma taxa de transmissão (<em>baud rate</em>) predefinida para sincronizar a comunicação. Para delimitar o início e o fim de cada trama de dados, são utilizados bits de início (<strong>start bit</strong>) e de fim (<strong>stop bit</strong>). Este modo é amplamente utilizado por microcontroladores e sensores devido à simplicidade e ao facto de que, geralmente, a quantidade de dados transmitidos não é muito elevada.
    </p>
    <p><strong>Formato típico de uma trama de dados no modo UART:</strong></p>
    <ul>
        <li>[Start Bit]</li>
        <li>[Data Bits] (geralmente 8 bits, mas pode variar)</li>
        <li>[Parity Bit] (opcional, usado para verificação de erro)</li>
        <li>[Stop Bit(s)]</li>
    </ul>

    <h4>Modo Síncrono (USART)</h4>
    <p>
        No modo síncrono, o transmissor envia um sinal de clock juntamente com os dados, garantindo que o recetor esteja sincronizado com o transmissor. Essa abordagem elimina a necessidade de bits de início e de fim, pois o clock sincroniza diretamente os dispositivos. Este modo é preferido em aplicações que exigem alta precisão e transferências rápidas de grandes volumes de dados, como entre dispositivos de alto desempenho.
    </p>

    <h3>Resumo das Diferenças</h3>
    <ul>
        <li>
            <strong>Assíncrono (UART):</strong> Não utiliza clock, depende de bits de início e fim para delimitação, sendo mais simples e adequado para comunicações de baixa velocidade.
        </li>
        <li>
            <strong>Síncrono (USART):</strong> Utiliza clock para sincronização, eliminando a necessidade de bits adicionais, sendo mais eficiente para transferências rápidas e precisas.
        </li>
    </ul>
            
        

    
    
    
    </section>
    <section id="hardware">
        <h2>Hardware</h2>
        <h3>Microcontroladores</h3>
        <h4>Tabela 2 - Microcontroladores </h4>
        <table border="2">
            <thead>
                <tr>
                    <th>Microcontrolador</th>
                    <th>Raspberry Pi Pico 2</th>
                    <th>ATmega328P</th>
                    <th>MSP430G2553</th>
                    <th>ESP32</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Núcleos</td>
                    <td>2</td>
                    <td>1</td>
                    <td>1</td>
                    <td>2</td>
                </tr>
                <tr>
                    <td>Frequência de Clock</td>
                    <td>133 MHz</td>
                    <td>16 MHz</td>
                    <td>16 MHz</td>
                    <td>Até 240 MHz</td>
                </tr>
                <tr>
                    <td>RAM</td>
                    <td>264 Bytes</td>
                    <td>2 KB</td>
                    <td>512 Bytes</td>
                    <td>520 KB</td>
                </tr>
                <tr>
                    <td>Flash</td>
                    <td>2 MB</td>
                    <td>32 KB</td>
                    <td>16 KB</td>
                    <td>4 MB</td>
                </tr>
                <tr>
                    <td>GPIO</td>
                    <td>26</td>
                    <td>23</td>
                    <td>24</td>
                    <td>34</td>
                </tr>
                <tr>
                    <td>ADC</td>
                    <td>3 (12 bits)</td>
                    <td>6 (10 bits)</td>
                    <td>8 (10 bits)</td>
                    <td>18 (12 bits)</td>
                </tr>
                <tr>
                    <td>Timer</td>
                    <td>3 (16 bits)</td>
                    <td>1 (16 bits) + 2 (8 bits)</td>
                    <td>2 (16 bits)</td>
                    <td>4 (16 bits)</td>
                </tr>
                <tr>
                    <td>I2C</td>
                    <td>Sim</td>
                    <td>Sim</td>
                    <td>Sim</td>
                    <td>Sim</td>
                </tr>
                <tr>
                    <td>SPI</td>
                    <td>Sim</td>
                    <td>Sim</td>
                    <td>Sim</td>
                    <td>Sim</td>
                </tr>
                <tr>
                    <td>UART</td>
                    <td>Sim</td>
                    <td>Sim</td>
                    <td>Sim</td>
                    <td>3</td>
                </tr>
                <tr>
                    <td>PWM</td>
                    <td>16</td>
                    <td>6</td>
                    <td>2</td>
                    <td>16</td>
                </tr>
                <tr>
                    <td>Compatível com Breadboard</td>
                    <td>Sim (DIP-40)</td>
                    <td>Sim (DIP-28)</td>
                    <td>Sim (DIP-28)</td>
                    <td>Sim (Dev Board)</td>
                </tr>
                <tr>
                    <td>Preço</td>
                    <td>⋍ 6 €</td>
                    <td>⋍ 3 €</td>
                    <td>⋍ 3.5 €</td>
                    <td>⋍10 €</td>
                </tr>
            </tbody>
        </table>
        
        <p>O microcontrolador escolhido foi o ATmega328P devido ao seu equilíbrio entre funcionalidade, simplicidade e custo, sendo ideal 
            para as necessidades deste projeto. Com um preço acessível, fornece desempenho suficiente para controlar o motor e processar os 
            dados do sensor de distância.
            Além disso, oferece um conjunto robusto de periféricos, como 23 GPIOs, 6 canais PWM, suporta I2C e UART e tem Timers suficientes 
            para o pretendido, garantindo integração eficiente com os componentes do sistema. 
            O formato DIP-28 facilita a aplicação em breadboards, e a sua vasta documentação torna-o ideal para projetos universitários, 
            promovendo uma curva de aprendizagem suave.
            </p>


            <h3>Sensores de distância</h3>
            <h4>Tabela 3 - Sensores </h4>
            <table border="2">
                <tr>
                    <th>Sensores de Distância</th>
                    <th>HC-SR04</th>
                    <th>VL53L0X</th>
                    <th>SRF05</th>
                    <th>MB1010</th>
                </tr>
                <tr>
                    <td>Tipo</td>
                    <td>Ultrassónico</td>
                    <td>Laser</td>
                    <td>Ultrassónico</td>
                    <td>Ultrassónico</td>
                </tr>
                <tr>
                    <td>Faixa de alcance</td>
                    <td>2 cm – 400 cm</td>
                    <td>30 mm – 2000 mm</td>
                    <td>2 cm – 400 cm</td>
                    <td>20 cm – 765 cm</td>
                </tr>
                <tr>
                    <td>Precisão</td>
                    <td>3 mm</td>
                    <td>3 mm</td>
                    <td>3 mm</td>
                    <td>1% da medição</td>
                </tr>
                <tr>
                    <td>Resolução</td>
                    <td>3 mm</td>
                    <td>1 mm</td>
                    <td>3 mm</td>
                    <td>1 cm</td>
                </tr>
                <tr>
                    <td>Tempo para medição</td>
                    <td>10 ms</td>
                    <td>30 ms</td>
                    <td>10 ms</td>
                    <td>60 ms</td>
                </tr>
                <tr>
                    <td>Alcance máx</td>
                    <td>4 metros</td>
                    <td>2 metros</td>
                    <td>4 metros</td>
                    <td>7,65 metros</td>
                </tr>
                <tr>
                    <td>Consumo</td>
                    <td>⋍15 mA</td>
                    <td>⋍20 mA</td>
                    <td>⋍20 mA</td>
                    <td>⋍30 mA</td>
                </tr>
                <tr>
                    <td>Comunicação</td>
                    <td>Pinos digitais</td>
                    <td>I2C</td>
                    <td>Pinos digitais</td>
                    <td>Analógica</td>
                </tr>
                <tr>
                    <td>Tensão de operação</td>
                    <td>5 V</td>
                    <td>2.8V – 3.3V</td>
                    <td>5V</td>
                    <td>5V</td>
                </tr>
                <tr>
                    <td>Compatibilidade</td>
                    <td>Sim</td>
                    <td>Sim</td>
                    <td>Sim</td>
                    <td>Sim</td>
                </tr>
                <tr>
                    <td>Ângulo medição</td>
                    <td>15º - 30º</td>
                    <td>25º</td>
                    <td>30º</td>
                    <td>40º</td>
                </tr>
                <tr>
                    <td>Preço</td>
                    <td>⋍ 1 €</td>
                    <td>⋍ 5 €</td>
                    <td>⋍ 2 €</td>
                    <td>⋍ 50 €</td>
                </tr>
            </table>
        
            <p>O Sonar HC-SR04 foi o escolhido para o projeto de mapeamento devido à sua combinação de precisão, baixo custo, e 
                facilidade de integração. Com uma faixa de alcance de até 4 metros e precisão de 3 mm, é adequado para medir distâncias 
                em áreas relativamente pequenas. O seu consumo de energia torna-o eficiente, especialmente em projetos alimentados por 
                baterias. Além disso, o HC-SR04 utiliza pinos digitais para comunicação, o que facilita a integração com microcontroladores 
                como o ATmega328P, simplificando o desenvolvimento do projeto. Com um preço acessível de cerca de 1€, é uma solução válida, 
                tornando-o uma escolha ideal para projetos universitários ou com orçamento limitado.</p>
        
            <h3>Motores</h3>
            <h4>Tabela 4 - Motores </h4>
            <table border="2">
                <tr>
                    <th>Motores</th>
                    <th>28BYJ-48</th>
                    <th>Step Motor 17HS4401</th>
                    <th>NEMA</th>
                </tr>
                <tr>
                    <td>Tipo</td>
                    <td>Passo a passo (unipolar)</td>
                    <td>Passo a passo (bipolar)</td>
                    <td>Passo a passo (bipolar)</td>
                </tr>
                <tr>
                    <td>Passos por volta completa</td>
                    <td><p>64 half-step ou 32 full-step</p>
                        Com redução interna: 4096 half-step ou 2048 full-step</td>
                    <td>200</td>
                    <td>200</td>
                </tr>
                <tr>
                    <td>Resolução</td>
                    <td>⋍ 0,088º por passo</td>
                    <td>1,8º por passo</td>
                    <td>1,8º por passo</td>
                </tr>
                <tr>
                    <td>Tensão</td>
                    <td>5V</td>
                    <td>2.8V</td>
                    <td>12 - 24V</td>
                </tr>
                <tr>
                    <td>Corrente</td>
                    <td>100 mA</td>
                    <td>1.68 A</td>
                    <td>2 - 3 A</td>
                </tr>
                <tr>
                    <td>Torque máx</td>
                    <td>34 mN.m</td>
                    <td>44 N.cm</td>
                    <td>150 mN.m</td>
                </tr>
                <tr>
                    <td>Controlo</td>
                    <td>Controlo de passos</td>
                    <td>Controlo de passos</td>
                    <td>Controlo de passos</td>
                </tr>
                <tr>
                    <td>Preço</td>
                    <td>⋍ 2 €</td>
                    <td>⋍ 10 € - 15 €</td>
                    <td>⋍ 15 € - 30 €</td>
                </tr>
            </table>
        
            <p>O motor 28BYJ-48 foi o escolhido para o projeto devido às suas características que se adequam bem aos requisitos de custo, 
                precisão e eficiência energética. Este motor passo a passo unipolar possui 4096 passos por volta completa, o que resulta em
                 uma resolução aproximada de 0,088º por passo. Essa resolução é suficiente para o controle de movimentos no mapeamento, onde 
                 uma precisão muito alta não é crítica para as necessidades do projeto.</p>
            <p>Opera com uma tensão de 5V e consome uma corrente de 100 mA, o que o torna uma escolha eficiente em termos de 
                consumo energético, sendo adequado para projetos que exigem autonomia e que podem ser alimentados por fontes de energia 
                limitadas, como baterias.
            <p>Outro fator relevante é o custo do motor, que é de aproximadamente 2€, tornando-o uma opção económica para projetos com 
                estas características. A simplicidade de controle, combinada com o baixo custo e a facilidade de 
                integração com microcontroladores como o ATmega328P, torna o 28BYJ-48 a escolha ideal para o desenvolvimento do sistema 
                de mapeamento neste projeto.</p>
        
            <h3>Drivers</h3>
            <h4>Tabela 6 - Drivers </h4>
            <table border="2">
            <table>
                <tr>
                    <th>Driver</th>
                    <th>ULN2003</th>
                    <th>L298N</th>
                    <th>A4988</th>
                </tr>
                <tr>
                    <td>Tipo</td>
                    <td>Passo a passo</td>
                    <td>Passo a passo</td>
                    <td>Passo a passo</td>
                </tr>
                <tr>
                    <td>Nº de canais</td>
                    <td>7</td>
                    <td>2</td>
                    <td>2</td>
                </tr>
                <tr>
                    <td>Corrente máx por canal</td>
                    <td>500 mA</td>
                    <td>2 A</td>
                    <td>2 A</td>
                </tr>
                <tr>
                    <td>Proteções</td>
                    <td>Sem</td>
                    <td>Sobrecorrente e sobreaquecimento</td>
                    <td>Sobrecorrente e sobreaquecimento</td>
                </tr>
                <tr>
                    <td>Tensão de operação</td>
                    <td>5 V</td>
                    <td>4,5 V a 36 V</td>
                    <td>8 V a 35 V</td>
                </tr>
                <tr>
                    <td>Interface</td>
                    <td>Pinos digitais</td>
                    <td>Pinos digitais</td>
                    <td>Pinos digitais</td>
                </tr>
                <tr>
                    <td>Preço</td>
                    <td>1 €</td>
                    <td>2 €</td>
                    <td>2 €</td>
                </tr>
            </table>
        
            <p>A escolha do ULN2003 para controlar o motor 28BYJ-48 no projeto é justificada pela sua excelente relação custo-benefício, 
                compatibilidade com motores unipolares e simplicidade de integração. Este driver é económico, com um preço baixo, e oferece 
                capacidade de corrente suficiente para o motor. Além disso, o consumo de energia é baixo, o que é vantajoso em sistemas 
                alimentados por baterias. O controle simples de passos do ULN2003 é adequado para as necessidades de precisão do projeto, 
                sendo a solução ideal para o controlo do motor.</p>
        
            <h3>Fonte de Alimentação</h3>
            <h4>Tabela 7 - Consumos </h4>
            <table border="2">
                <tr>
                    <th>Componente</th>
                    <th>Tensão</th>
                    <th>Corrente Funcionamento</th>
                    <th>Corrente Máx.</th>
                    <th>Potência</th>
                    <th>Quantidade</th>
                    <th>Total Potência Máx</th>
                    <th>Total Potência Funcionamento</th>
                </tr>
                <tr>
                    <td>ATmega328p</td>
                    <td>5 V</td>
                    <td>10 mA</td>
                    <td>15 mA</td>
                    <td>75 mW</td>
                    <td>1</td>
                    <td>75 mW</td>
                    <td>50 mW</td>
                </tr>
                <tr>
                    <td>LED</td>
                    <td>2 V</td>
                    <td>10 mA</td>
                    <td>20 mA</td>
                    <td>40 mW</td>
                    <td>1</td>
                    <td>40 mW</td>
                    <td>20 mW</td>
                </tr>
                <tr>
                    <td>Motor 28BYJ-48</td>
                    <td>5 V</td>
                    <td>100 mA</td>
                    <td>150 mA</td>
                    <td>750 mW</td>
                    <td>2</td>
                    <td>1,5 W</td>
                    <td>500 mW</td>
                </tr>
                <tr>
                    <td>Sensor HC-SR04</td>
                    <td>5 V</td>
                    <td>15 mA</td>
                    <td>30 mA</td>
                    <td>150 mW</td>
                    <td>1</td>
                    <td>150 mW</td>
                    <td>75 mW</td>
                </tr>
                <tr>
                    <td>Driver ULN2003</td>
                    <td>5 V</td>
                    <td>1uA</td>
                    <td>1uA</td>
                    <td>5uW</td>
                    <td>2</td>
                    <td>10uW</td>
                    <td>10uW</td>
                </tr>
                <tr>
                    <td>Total</td>
                    <td>-</td>
                    <td>135 mA</td>
                    <td>215 mA</td>
                    <td>1,015 W</td>
                    <td>7</td>
                    <td>1,765 W</td>
                    <td>645 mW</td>
                </tr>
            </table>
        
            <p>O Cálculo Total de Potência em Funcionamento parece-nos o mais adequado, pois os componentes não irão estar em 
                funcionamento em simultâneo.</p>
        
        

        <h3>Esquema Elétrico</h3>
        <figure>
            <img src="images/esq_elet.png" alt="Esquema Elétrico">
            <figcaption>Esquema elétrico</figcaption>
        </figure>

        <h3>Layout do PCB</h3>
        <figure>
            <img src="images/pcb.png" alt="Layout do PCB">
            <figcaption>Layout do PCB</figcaption>
        </figure>

        <h3>Modelo 3D do PCB</h3>
        <figure>
            <img src="images/pcb3dfront.png" alt="Modelo 3D do PCB Front">
            <figcaption>Modelo 3D do PCB Front</figcaption>
        </figure>
        
        <figure>
            <img src="images/pcb3dback.png" alt="Modelo  3D do PCB Back">
            <figcaption>Modelo 3D do PCB Back</figcaption>
        </figure>
    </section>



    <section id="software">
        <h2>Software</h2>
        <h3>Fluxogramas</h3>
        <h3>Linguagem C (microcontrolador)</h3>
        <h3>Função Main</h3>
        <figure>
            <img src="images/main.png" alt="Fluxograma função main">
            <figcaption>Fluxograma função main</figcaption>
        </figure>

        <h4>Exemplo de Código</h4>
 
        <pre><code>
            int main(void)
            {
                uint16_t distance;
                uint16_t GrausXZ = 0;
                uint16_t GrausXY = 0;
            
                // Inicialização
                init();
                
                while (1)
                {
            
                    while (GrausXZ < 17)
                    {
                        GrausXY = 0;
                        while (GrausXY < 26 && GrausXY >= 0)
                        {
                            distance = distance();
                            sprintf(transmit_buffer, "%u,%u,%u\n", GrausXZ, GrausXY, distance);
                            send_message(transmit_buffer);
                            MotorXY_AHO(20);
                            GrausXY++;
                            _delay_ms(25);
                        }
            
                        MotorXZ_AHO(32);
                        GrausXZ++;
                        _delay_ms(20);
                        
                        while (GrausXY < 27 && GrausXY > 0)
                        {
                            distance = distance();
                            sprintf(transmit_buffer, "%u,%u,%u\n", GrausXZ, GrausXY, distance);
                            send_message(transmit_buffer);
                            MotorXY_HOR(20);
                            GrausXY--;
                            _delay_ms(25);
                        }
                        MotorXZ_AHO(32);
                        GrausXZ++;
                        _delay_ms(20);
                    }
                    MotorXZ_HOR(512);
                }
            }
                </code></pre>

                <h4>Explicação da Função <code>main</code></h4>

                <div class="explanation">
    <p>A função principal do projeto <code>main</code> segue um ciclo infinito <code>while</code>, onde realiza verificações contínuas em duas variáveis, <code>GrausXZ</code> e <code>GrausXY</code>, e faz medições usando a função <code>distance()</code>. O processo é organizado da seguinte forma:</p>

    <ul>
        <li><strong>Primeira verificação:</strong>
            <ul>
                <li>Se <code>GrausXZ</code> for menor que 17, o programa entra no primeiro ciclo <code>while</code>.</li>
            </ul>
        </li>
        <li><strong>Dentro do primeiro ciclo:</strong>
            <ul>
                <li>Verifica-se se <code>GrausXY</code> está entre 0 e 26 (inclusive).</li>
                <li>Se a condição for verdadeira, realiza-se as seguintes ações:
                    <ul>
                        <li>Faz a medição de distância com a função <code>distance()</code>.</li>
                        <li>Envia os valores de <code>GrausXZ</code>, <code>GrausXY</code> e a distância para o PC usando a função <code>send_message()</code>.</li>
                        <li>O motor gira os graus definidos no sentido horário.</li>
                        <li>Incrementa <code>GrausXY</code>.</li>
                        <li>Faz um delay de 20 ms.</li>
                    </ul>
                </li>
            </ul>
        </li>
        <li><strong>Após a condição ser falsa:</strong>
            <ul>
                <li>O motor gira no sentido horário de forma paralela à base.</li>
                <li><code>GrausXZ</code> é incrementado.</li>
                <li>Após um delay de 20 ms, o programa entra em um novo ciclo <code>while</code>.</li>
            </ul>
        </li>
        <li><strong>Segunda verificação:</strong>
            <ul>
                <li>A nova condição verifica se <code>GrausXY</code> está entre 0 e 26 (inclusive).</li>
                <li>Neste ciclo, o motor gira no sentido anti-horário, e a variável <code>GrausXY</code> é decrementada.</li>
            </ul>
        </li>
        <li><strong>Fim do ciclo:</strong>
            <ul>
                <li>Quando <code>GrausXY</code> atinge o valor de 0, o programa sai do ciclo e gira o motor de forma paralela à base, decrementando <code>GrausXZ</code>.</li>
                <li>Após um novo delay de 20 ms, o programa retorna à comparação inicial.</li>
            </ul>
        </li>
        <li><strong>Condição final:</strong>
            <ul>
                <li>O ciclo continua até que <code>GrausXZ</code> atinja 17.</li>
                <li>Quando isso acontecer, o motor paralelo à base gira no sentido anti-horário para retornar à posição inicial.</li>
            </ul>
        </li>
    </ul>
</div>

                <h3>Função send_message</h3>
                <figure>
                    <img src="images/send.png" alt="Fluxograma função send_message">
                    <figcaption>Fluxograma função send_message</figcaption>
                </figure>
        
                <h4>Exemplo de Código</h4>

                <pre>
                    void send_message(char *buffer)
                    {
                        unsigned char i = 0;
                        while (buffer[i] != '\0')
                        {
                            while ((UCSR0A & 1 << UDRE0) == 0);
                            UDR0 = buffer[i];
                            i++;
                        }
                    }
                    </pre>

                    <h4>Explicação da Função <code>send_message()</code></h4>
                    <div class="explanation">
                        <p>A função <code>send_message()</code> é responsável por transmitir uma cadeia de caracteres através do registo de transmissão UART. O funcionamento detalhado é o seguinte:</p>
                    
                        <ul>
                            <li><strong>Receção do buffer e Inicialização do índice:</strong>
                                <ul>
                                    <li>A função recebe um ponteiro para uma cadeia de caracteres <code>buffer</code>, que contém a mensagem a ser transmitida.</li>
                                    <li>Declara-se uma variável <code>i</code> e inicializa-se com <code>0</code>. Esta variável serve como índice para percorrer os caracteres no <code>buffer</code>.</li>
                                </ul>
                            </li>
                            <li><strong>Ciclo Principal:</strong>
                                <ul>
                                    <li>A função entra num ciclo <code>while</code> que percorre cada caractere do <code>buffer</code> até encontrar o caractere nulo (<code>'\0'</code>), que indica o final da string.</li>
                                </ul>
                            </li>
                            <li><strong>Verificação do Buffer de Transmissão:</strong>
                                <ul>
                                    <li>Dentro do ciclo principal, há um outro ciclo <code>while</code> que verifica o estado do registo <code>UCSR0A</code> para confirmar se o bit <code>UDRE0</code> (Buffer de Dados de Transmissão Vazio) está definido.</li>
                                    <li>Este ciclo permanece ativo até que o registo esteja pronto para receber um novo byte.</li>
                                </ul>
                            </li>
                            <li><strong>Transmissão do Caractere:</strong>
                                <ul>
                                    <li>Após a verificação, o caractere atual <code>buffer[i]</code> é colocado no registo de transmissão <code>UDR0</code>, iniciando a sua transmissão.</li>
                                    <li>A variável <code>i</code> é incrementada para processar o próximo caractere da cadeia.</li>
                                </ul>
                            </li>
                            <li><strong>Repetição:</strong>
                                <ul>
                                    <li>O processo repete-se até que todos os caracteres da string sejam transmitidos, ou seja, até encontrar <code>'\0'</code>.</li>
                                </ul>
                            </li>
                            <li><strong>Saída:</strong>
                                <ul>
                                    <li>Quando a string é completamente transmitida, a função termina.</li>
                                </ul>
                            </li>
                        </ul>
                    </div>

                    <h3>Interrupção Timer 2</h3>
                    <figure>
                        <img src="images/timer2.png" alt="Fluxograma Interrupção TImer 2">
                        <figcaption>Fluxograma Interrupção Timer 2</figcaption>
                    </figure>
            
                    <h4>Exemplo de Código</h4>
                <pre>
                    ISR(TIMER2_COMPA_vect)
                    {
                        led_count++; // Incrementa o contador em cada interrupção
                    
                        if (led_count > 30)
                        {                             // 30 interrupções correspondem a aproximadamente 0,5 segundos
                            led_count = 0;            // Reseta o contador
                            PORTD ^= (1 << LED_PIN);  // Alterna o estado do LED
                        }
                    }
                    </pre>

                    <h4>Explicação da Rotina ISR(TIMER2_COMPA_vect)</h4>
                    <ul>
                        <li><strong>Início da Interrupção:</strong>
                            <ul>
                                <li>A rotina é executada automaticamente sempre que ocorre uma interrupção por comparação no Timer2, gerada quando o valor do contador atinge o valor definido no registo <code>OCR2A</code>.</li>
                            </ul>
                        </li>
                        <li><strong>Incremento do Contador <code>led_count</code>:</strong>
                            <ul>
                                <li>A variável global <code>led_count</code> é incrementada em cada interrupção.</li>
                                <li>Este contador é usado para acompanhar o número de interrupções ocorridas.</li>
                            </ul>
                        </li>
                        <li><strong>Verificação do Contador <code>led_count</code>:</strong>
                            <ul>
                                <li>A rotina verifica se o valor de <code>led_count</code> ultrapassou 30.</li>
                            </ul>
                        </li>
                        <li><strong>Reset do Contador (se condição verdadeira):</strong>
                            <ul>
                                <li>Se o valor de <code>led_count</code> for maior que 30, o valor de <code>led_count</code> passa a ser 0.</li>
                                <li>Este "reset" permite recomeçar o ciclo de contagem.</li>
                            </ul>
                        </li>
                        <li><strong>Alternar o Estado do LED:</strong>
                            <ul>
                                <li>Alterna o estado lógico do pino associado ao LED.</li>
                                <li>Se está ligado, desliga; se está desligado, liga.</li>
                            </ul>
                        </li>
                        <li><strong>Saída da Rotina:</strong>
                            <ul>
                                <li>Após alternar o estado do LED, a rotina retorna ao programa principal.</li>
                            </ul>
                        </li>
                    </ul>
                    

                    <h3>Função distance</h3>
                    <figure>
                        <img src="images/distance.png" alt="Fluxograma Função distance">
                        <figcaption>Fluxograma Função distance</figcaption>
                    </figure>

                    <h4>Exemplo de Código</h4>
                        <pre><code>
                        uint16_t distance()
                        {
                            uint16_t duration = 0;
                            uint16_t distance = 0;

                            PORTD &= ~(1 << TRIG_PIN);
                            _delay_us(2);
                            PORTD |= (1 << TRIG_PIN);
                            _delay_us(10);
                            PORTD &= ~(1 << TRIG_PIN);

                            while (!(PIND & (1 << ECHO_PIN)))
                                ;
                            TCNT1 = 0;
                            TCCR1B |= (1 << CS11);

                            while (PIND & (1 << ECHO_PIN))
                            {
                                if (TCNT1 > 60000)
                                    break;
                            }
                            TCCR1B = 0;
                            duration = TCNT1;

                            distance = (duration / 116
                            );

                            return distance;
                        }
                        </code></pre>

                        <h4>Explicação da Função distance()</h4>

<p>A função <code>distance()</code> foi desenvolvida para trabalhar com um sensor ultrassónico, utilizando o Timer 1 como base de medida
     de distância. A lógica consiste em determinar a distância através da emissão de um sinal ultrassónico, que é refletido e retorna 
     para o sensor. A função irá medir o intervalo de tempo entre a emissão e receção do sinal emitido pelo sonar.</p>
<p>O sensor possui dois pinos digitais para realizar essa função:</p>
<ul>
    <li><strong>Pino TRIG:</strong> Efetua a emissão do sinal ultrassónico.</li>
    <li><strong>Pino ECHO:</strong> Aciona quando o sinal refletido é recebido.</li>
</ul>
<p>A distância pode ser calculada utilizando a fórmula:</p>
<p><strong>Distância = (Duração × velocidade do som) / 2</strong></p>
<p>A velocidade do som foi obtida a partir do tempo de transmissão em distâncias conhecidas, permitindo calcular a velocidade média do 
    som em metros por segundo. No sensor utilizado, a velocidade do som é de 346,26 m/s.</p>

<figure>
    <img src="images/calibracao_sonar.png" alt="Gráfico Leitura Sonar">
    <figcaption>Gráfico Leitura Sonar Distância (mm) vs Tempo (ms)</figcaption>
</figure>
<p>A velocidade do som calculada a partir do gráfico é igual ao dobro do declive.</p>



<p>A função <code>distance()</code> está organizada da seguinte forma:</p>


<ul>
    <li><strong>Inicialização:</strong>
        <ul>
            <li>As variáveis <code>duration</code> e <code>distance</code> são inicializadas com valor 0.</li>
            <li><code>duration</code> armazena o tempo que o sinal ultrassónico demorou entre o objeto e o sensor.</li>
            <li><code>distance</code> armazena a distância após a conversão do tempo.</li>
        </ul>
    </li>
    <li><strong>Envio do Pulso Ultrassónico:</strong>
        <ul>
            <li>Um pulso de 10 µs é enviado pelo pino <code>TRIG</code> para iniciar a medição.</li>
        </ul>
    </li>
    <li><strong>Confirma o Estado do Pino de Recepção:</strong>
        <ul>
            <li>O programa verifica se o pino <code>ECHO</code> está em nível alto.</li>
            <li>Se o pino <code>ECHO</code> estiver em nível alto, a contagem de tempo é inicializada.</li>
        </ul>
    </li>
    <li><strong>Verificar o Estado do Pino de Recepção:</strong>
        <ul>
            <li>Enquanto o pino <code>ECHO</code> estiver em nível alto, o Timer1 continua a contagem.</li>
            <li>Existe um tempo máximo de 60000, equivalente a 0,03 segundos (5,145 metros de distância).</li>
            <li>O sensor possui um alcance máximo de 4 metros.</li>
        </ul>
    </li>
    <li><strong>Encerramento da Contagem:</strong>
        <ul>
            <li>Quando o pino <code>ECHO</code> retorna a nível baixo, o timer é parado.</li>
            <li>O valor atual do <code>TCNT1</code> (contagem do Timer1) é atribuído à variável <code>duration</code>.</li>
        </ul>
    </li>
    <li><strong>Cálculo da Distância:</strong>
        <ul>
            <li>A distância é calculada atrvés da fórmula <code>Distância = (Duração × velocidade do som) / 2</code>.</li>
            <li>A velocidade do som utilizada é de 346,26 m/s.</li>
        </ul>
    </li>
    <li><strong>Retorno do Resultado:</strong>
        <ul>
            <li>A distância calculada é retornada pela função <code>distance()</code>.</li>
        </ul>
    </li>
</ul>



<h4>Funções dos Motores</h4>
                    <figure>
                        <img src="images/motor.png" alt="Fluxograma Motores">
                        <figcaption>Fluxograma Motores</figcaption>
                    </figure>

                    <h4>Exemplo de Código</h4>

<pre>
<code>
void MotorXZ_HOR(int steps)
{
    for (int i = 0; i < steps; i++)
    {
        for (int j = 0; j < 4; j++)
        {
            PORTC = HOR_XZ[j];
            _delay_ms(STEP_DELAY);
        }
    }
}

void MotorXZ_AHO(int steps)
{
    for (int i = 0; i < steps; i++)
    {
        for (int j = 0; j < 4; j++)
        {
            PORTC = AHO_XZ[j];
            _delay_ms(STEP_DELAY);
        }
    }
}

void MotorXY_HOR(int steps)
{
    for (int i = 0; i < steps; i++)
    {
        for (int j = 0; j < 4; j++)
        {
            PORTB = HOR_XY[j];
            _delay_ms(STEP_DELAY);
        }
    }
}

void MotorXY_AHO(int steps)
{
    for (int i = 0; i < steps; i++)
    {
        for (int j = 0; j < 4; j++)
        {
            PORTB = AHO_XY[j];
            _delay_ms(STEP_DELAY);
        }
    }
}
</code>
</pre>

<h4>Explicação das Funções</h4>

<ul>
    <li><strong>Início:</strong>
        <ul>
            <li>A função começa recebendo o número de passos <code>steps</code> como argumento.</li>
        </ul>
    </li>
    <li><strong>Inicializar Variáveis:</strong>
        <ul>
            <li>A variável <code>i</code> é inicializada como 0, para controlar o número de passos totais da rotação.</li>
        </ul>
    </li>
    <li><strong>Verificar Número de Passos (<code>i &lt; steps</code>):</strong>
        <ul>
            <li>Verifica se <code>i</code> é menor que o número total de passos (<code>steps</code>).</li>
            <li>Se sim, continua para o próximo passo.</li>
            <li>Se não, a função termina.</li>
        </ul>
    </li>
    <li><strong>Ciclo Interno de 4 Passos (<code>j &lt; 4</code>):</strong>
        <ul>
            <li>Inicializa a variável <code>j</code> com 0.</li>
            <li>Verifica se <code>j</code> é menor que 4.</li>
            <li>Se sim, entra no ciclo para enviar o valor correspondente ao motor.</li>
            <li>Se não, sai do ciclo interno.</li>
        </ul>
    </li>
    <li><strong>Carregar Valor no Porto Correspondente:</strong>
        <ul>
            <li>Dependendo da função, o valor de <code>HOR_XZ[j]</code>, <code>AHO_XZ[j]</code>, <code>HOR_XY[j]</code> ou <code>AHO_XY[j]</code> é carregado no respetivo porto <code>PORTC</code> ou <code>PORTB</code>.</li>
            <li>Se for a função <code>MotorXZ_HOR</code>, o valor de <code>HOR_XZ[j]</code> é carregado em <code>PORTC</code>.</li>
            <li>Se for a função <code>MotorXZ_AHO</code>, o valor de <code>AHO_XZ[j]</code> é carregado em <code>PORTC</code>.</li>
            <li>Se for a função <code>MotorXY_HOR</code>, o valor de <code>HOR_XY[j]</code> é carregado em <code>PORTB</code>.</li>
            <li>Se for a função <code>MotorXY_AHO</code>, o valor de <code>AHO_XY[j]</code> é carregado em <code>PORTB</code>.</li>
            <li>Há um delay entre cada passo, controlado por <code>_delay_ms(STEP_DELAY)</code>.</li>
        </ul>
    </li>
    <li><strong>Incrementar <code>j</code>:</strong>
        <ul>
            <li>O índice <code>j</code> é incrementado em 1.</li>
            <li>Volta ao ponto 4 para continuar com o próximo ciclo de 4 passos.</li>
        </ul>
    </li>
    <li><strong>Incrementar <code>i</code>:</strong>
        <ul>
            <li>Após o ciclo interno de 4 passos, o índice <code>i</code> é incrementado em 1.</li>
            <li>Isso indica que um conjunto de 4 passos foi completado.</li>
        </ul>
    </li>
    <li><strong>Voltar à Verificação <code>i &lt; steps</code>:</strong>
        <ul>
            <li>Volta ao ponto 3 para verificar se o número total de passos foi alcançado.</li>
            <li>Se <code>i = steps</code>, a função termina.</li>
        </ul>
    </li>
</ul>

<h4>Função init</h4>
                    <figure>
                        <img src="images/init.png" alt="Fluxograma Inicializações/Configurações">
                        <figcaption>Fluxograma Inicializações/Configurações</figcaption>
                    </figure>

                    <h4>Exemplo de Código</h4>

                    <h4>Função init()</h4>
<pre><code>
void init()
{
    DDRC = 0b00111100;
    PORTC = 0x00;

    DDRB = 0b00011110;
    PORTB = 0x00;

    DDRD |= (1 << PD6);

    DDRD |= (1 << TRIG_PIN);
    DDRD &= ~(1 << ECHO_PIN);

    TCCR2A = (1 << WGM21);
    TCCR2B |= (1 << CS22) | (1 << CS21) | (1 << CS20);
    OCR2A = 251;
    TIMSK2 |= (1 << OCIE2A);

    UBRR0H = 0;
    UBRR0L = 103;
    UCSR0A = (1 << U2X0);
    UCSR0B = (1 << RXCIE0) | (1 << RXEN0) | (1 << TXEN0);
    UCSR0C = (1 << UCSZ01) | (1 << UCSZ00);

    sei();
}
</code></pre>

<h4>Explicação da Função <code>init()</code></h4>

    <li>
        <strong>Configuração dos Portos para os Motores:</strong>
        <ul>
            <li>Os pinos do <code>PORTC</code> e <code>PORTB</code> são configurados como saídas para o controlo dos motores XZ e XY.</li>
            <li>Os valores iniciais desses portos são definidos como <code>0</code>.</li>
        </ul>
    </li>
    <li>
        <strong>Configuração do Pino <code>PD6</code>: pino do LED</strong>
        
    </li>
    <li>
        <strong>Configuração dos Pinos <code>TRIG</code> e <code>ECHO</code>:</strong>
        <ul>
            <li><code>TRIG</code> é configurado como saída para enviar sinais ultrassónicos.</li>
            <li><code>ECHO</code> é configurado como entrada para receber o sinal refletido.</li>
        </ul>
    </li>
    <li>
        <strong>Configuração do Timer 2 no Modo CTC:</strong>
        <ul>
            <li>Ativa o modo de contagem comparativa (CTC).</li>
            <figure>
                <img src="images/ctc.png" alt="Funcionamento do Modo CTC do Timer 2">
                <figcaption>Funcionamento do Modo CTC do Timer 2</figcaption>
            </figure>
            <figure>
                <img src="images/modos.png" alt="Tabela de Modos do Timer 2">
                <figcaption>Tabela de Modos do Timer 2</figcaption>
            </figure>
            <figure>
                <img src="images/registoA.png" alt="Tabela Registo A do Timer 2">
                <figcaption>Tabela Registo A do Timer 2</figcaption>
            </figure>
            <li>Configura o prescaler para controlar a frequência do timer.</li>
            <figure>
                <img src="images/prescaler.png" alt="Tabela prescaler Timer 2">
                <figcaption>Tabela prescaler Timer 2</figcaption>
            </figure>
            <li>Define o valor de comparação <code>OCR2A</code> para gerar uma frequência de 31 Hz.</li>
            <figure>
                <img src="images/expressao_ctc.png" alt="Expressão cálculo de OCR2A Timer 2">
                <figcaption>Expressão cálculo de OCR2A Timer 2</figcaption>
            </figure>
            <li>Ativa a interrupção de comparação A para o Timer 2.</li>
            <li>Ajusta o Prescaler para 1024.</li>
            <figure>
                <img src="images/registoB.png" alt="Tabela Registo B do Timer 2">
                <figcaption>Tabela Registo B do Timer 2</figcaption>
            </figure>
        </ul>
    </li>
    <li>
        <strong>Configuração da USART:</strong>
        <ul>
            <li>Define o baud rate para 19200.</li>
            <figure>
                <img src="images/baud_express.png" alt="Expressão Cálculo Baudrate">
                <figcaption>Expressão Cálculo Baudrate</figcaption>
            </figure>
            <figure>
                <img src="images/baud_table.png" alt="Tabela Baudrate">
                <figcaption>Tabela Baudrate</figcaption>
            </figure>
            <li>Habilita o receptor, transmissor e interrupções para comunicação serial.</li>
            <ul>
                <li><code>RXCIE0</code>: Habilita interrupções quando um byte é recebido.</li>
                <li><code>RXEN0</code>: Habilita a receção de dados.</li>
                <li><code>TXEN0</code>: Habilita a transmissão de dados.</li>
            </ul>
            <figure>
                <img src="images/usart_registoB.png" alt="Registo B das Configurações USART">
                <figcaption>Registo B das Configurações USART</figcaption>
            </figure>
            <li>Configura o modo de transmissão para 8 bits de dados sem paridade.</li>
            <ul>
                <li><code>UCSZ01</code> e <code>UCSZ00</code>: Configuram o tamanho dos dados para 8 bits.</li>
                <li>Não há configuração para paridade (<code>UPM01</code> ou <code>UPM00</code>), ou seja, sem paridade.</li>
                <li>O stop bit é padrão (1 bit), pois <code>USBS0 = 0</code>.</li>
            </ul>
            <figure>
                <img src="images/usart_registoC.png" alt="Registo C das Configurações USART">
                <figcaption>Registo C das Configurações USART</figcaption>
            </figure>
        </ul>
    </li>
    <li>
        <strong>Habilitação de Interrupções Globais:</strong>
        <ul>
            <li>Ativa as interrupções globais no microcontrolador com a instrução <code>sei()</code>.</li>
        </ul>
    </li>
</ol>

<h3>Python (interface)</h3>
<figure>
    <img src="images/python.png" alt="Fluxograma Interface Python">
    <figcaption>Fluxograma Interface Python</figcaption>
</figure>
<h4>Exemplo de Código</h4>


<h4>Explicação</h4>


<p>Interface gráfica para visualizar o mapeamento da área onde se encontra. Utilizou-se Python pela sua simplicidade
     e capacidade de desenvolvimento de aplicações, bem como pela facilidade de interligação com 
    aplicações mais complexas. A aplicação foi desenvolvida utilizando bibliotecas existentes facilmente integradas no Python.</p>

<h3>Bibliotecas Utilizadas</h3>

<h4>Bibliotecas do Python Padrão</h4>
<ul>
    <li><b>Tkinter</b>: Biblioteca padrão do Python para criação de interfaces gráficas, como botões e blocos de texto.</li>
    <li><b>Threading</b>: Usada para trabalhar com threads, essencial para executar tarefas em paralelo, como a leitura de dados serial 
        e garantir que a interface gráfica continue responsiva, capaz de atualizar o gráfico 3D.</li>
    <li><b>Math</b>: Biblioteca padrão para cálculos matemáticos.</li>
</ul>

<h4>Outras Bibliotecas</h4>
<ul>
    <li><b>Serial</b>: Utilizada para comunicação com portas série. Requer instalação prévia com o comando 
        <code>pip install pyserial</code>.</li>
    <li><b>Matplotlib</b>: Biblioteca para criação de gráficos 2D e 3D. Requer instalação prévia com o comando 
        <code>pip install matplotlib</code>.</li>
</ul>

<h3>Fluxograma</h3>

<ol>
    <li><b>Inicialização da Aplicação</b>:
        <ul>
            <li>Criação da interface gráfica utilizando Tkinter.</li>
            <li>Componentes GUI: Combobox para seleção de portas, botões de "Iniciar" e "Parar", área de texto, e gráfico 3D.</li>
            <li>Configuração do evento para fechar a janela.</li>
        </ul>
    </li>
    <li><b>Atualização das Portas COM</b>:
        <ul>
            <li>Pesquisa das portas COM disponíveis no computador.</li>
            <li>Cópia da lista de portas disponíveis para a Combobox.</li>
        </ul>
    </li>
    <li><b>Leitura Serial</b>:
        <ul>
            <li>Ao pressionar "Iniciar Leitura":
                <ul>
                    <li>Verifica se uma porta COM foi selecionada.</li>
                    <li>Configura a conexão serial.</li>
                    <li>Inicia a thread de leitura.</li>
                </ul>
            </li>
            <li>Durante a leitura:
                <ul>
                    <li>Lê dados da porta serial em um loop contínuo enquanto a leitura estiver ativa.</li>
                    <li>Processa os dados recebidos para:
                        <ul>
                            <li>Atualizar a área de texto com os valores recebidos.</li>
                            <li>Atualizar o gráfico 3D com as coordenadas calculadas.</li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>
    </li>
    <li><b>Atualização do Gráfico 3D</b>:
        <ul>
            <li>Calcula coordenadas (x, y, z) com base nos valores de entrada.</li>
            <li>Adiciona os pontos ao gráfico e atualiza a visualização.</li>
            <li>Salva uma imagem do gráfico quando o sensor executa uma volta completa.</li>
        </ul>
    </li>
    <li><b>Ao pressionar "Parar Leitura"</b>:
        <ul>
            <li>Desativa a leitura.</li>
            <li>Fecha a conexão serial.</li>
            <li>Limpa o gráfico e a área de texto.</li>
        </ul>
    </li>
    <li><b>Fechar Aplicação</b>:
        <ul>
            <li>Pára a leitura (se ativa).</li>
            <li>Finaliza a thread de leitura.</li>
            <li>Encerra a aplicação.</li>
        </ul>
    </li>
</ol>
     

    </section>

    <section id="resultados">
        <h2>Resultados</h2>
    </section>

    <ul>
        <h3>Funcionamento Geral</h3>
    <p>Nesta seção, apresentamos os resultados obtidos durante o desenvolvimento e teste do projeto, evidenciando o funcionamento 
        esperado do sistema. Os resultados foram documentados por meio de imagens, vídeos e capturas de ecrã, que ilustram o desempenho 
        do sistema de mapeamento 3D, a interface gráfica e as medições realizadas.</p>
    
    <h3>Resultados das Medições</h3>
    <p>Os dados obtidos pelo sensor foram processados e exibidos na interface gráfica desenvolvida. Entre os destaques dos 
        resultados estão:</p>
    <ul>
        <li><strong>Mapeamento 3D da área envolvente:</strong> Os pontos recolhidos pelo sensor de distância foram suficientemente
            precisos, formando um mapa representativo do ambiente ao redor.</li>
        <li><strong>Visualização Gráfica:</strong> A aplicação gráfica permitiu uma análise clara e intuitiva dos dados medidos, 
            com atualizações em tempo real.</li>
    </ul>
    
    <h3>Documentação Visual</h3>
    
    <ul>
        <li><strong>Fotos do protótipo em funcionamento:</strong> Mostrando a montagem do hardware e a interação do sistema com o ambiente.</li>
        
        <div>
            <figure>
                <img src="images/maqueteA.jpeg" alt="Maquete do Projeto">
                <figcaption>Maquete do Projeto</figcaption>
            </figure>
            <figure>
                <img src="images/maqueteB.jpeg" alt="Maquete do Projeto">
                <figcaption>Maquete do Projeto</figcaption>
            </figure>
            <figure>
                <img src="images/placa.jpeg" alt="Breadboard">
                <figcaption>Breadboard</figcaption>
            </figure>
        </div>
        <li><strong>Capturas de tela da interface gráfica:</strong> Evidenciando a funcionalidade do sistema de visualização.</li>
        <p>Para uma melhor interpretação devemos acrescentar que os resultados apresentados são
            da medição de uma caixa 40x40x65(cm) apresentamos a seguir:</p>
        <div>
            <figure>
                <img src="images/sup.png" alt="Representação 3D Vista Superior">
                <figcaption>Representação 3D Vista Superior</figcaption>
            </figure>
            <figure>
                <img src="images/3dlateralA.png" alt="Representação 3D Lateral">
                <figcaption>Representação 3D Lateral</figcaption>
            </figure>
            <figure>
                <img src="images/3dlateralB.png" alt="Representação 3D Lateral">
                <figcaption>Representação 3D Lateral</figcaption>
            </figure>
        </div>
        <li><strong>Vídeos do sistema em operação:</strong> Demonstrando a coleta de dados, o movimento da torre giratória e a 
            geração do mapa.</li>

            <video controls width="640" style="display: block; margin: 0 auto;">
                <source src="images/video.MOV" type="video/quicktime">
                O seu navegador não suporta a reprodução de vídeos. Por favor, atualize para um navegador moderno ou descarregue o vídeo <a href="caminho/para/o/video.mp4">aqui</a>.
            </video>
    </section>


    <section id="conclusoes">
        <h2>Conclusões</h2>
    </section>

    <ul>
    <p>O projeto atingiu os objetivos principais estabelecidos, demonstrando a funcionalidade do sistema de mapeamento 2D e a integração
         eficiente entre hardware e software. Contudo, como em qualquer desenvolvimento, alguns desafios foram identificados, e há margem 
         para melhorias e expansões futuras.</p>
    
    <h3>Desafios Encontrados</h3>
    <p>Durante a implementação, um dos principais desafios foi a integração do sensor VL53L0X utilizando o protocolo I²C. Apesar de termos 
        conseguido capturar e analisar tramas de comunicação, acreditamos que algumas configurações ficaram incompletas, possivelmente 
        devido a informações limitadas no datasheet do sensor, que dificultaram a configuração correta.</p>

        <ul>
            <h3>Protocolo I²C</h3>
            <p>
                O <strong>protocolo I²C</strong> (Inter-Integrated Circuit) é um tipo de comunicação serial projetado para permitir a troca de dados
                 entre dispositivos usando apenas dois fios. Desenvolvido pela Philips Semiconductors (atualmente NXP), é amplamente utilizado devido
                  à sua simplicidade e eficiência, sendo aplicado em sensores, displays, memórias e outros periféricos.
            </p>
        
            <h3>1. Características Principais</h3>
            <p>
                O protocolo I²C utiliza um barramento bidirecional que permite a ligação de múltiplos dispositivos. Este barramento é composto por
                 dois fios:
            </p>
            <ul>
                <li><strong>SDA (Serial Data):</strong> Transporta os dados.</li>
                <li><strong>SCL (Serial Clock):</strong> Fornece o sinal de clock.</li>
            </ul>
            <p>
                Cada dispositivo no barramento é identificado por um endereço único, permitindo a comunicação entre múltiplos mestres e escravos 
                no mesmo sistema.
            </p>
        
            <h3>2. Funcionamento Básico</h3>
            <p>
                O protocolo I²C segue uma abordagem de comunicação <strong>master-slave</strong>, onde:
            </p>
            <ul>
                <li>O mestre controla o clock e inicia as comunicações.</li>
                <li>Os escravos apenas respondem às solicitações do mestre.</li>
            </ul>
            <p>Os passos básicos de funcionamento incluem:</p>
            <ul>
                <li>
                    <strong>Início da Comunicação:</strong> O mestre gera uma condição de início (<strong>START</strong>) ao definir a 
                    linha <code>SDA</code> como nível lógico baixo enquanto <code>SCL</code> permanece alto.
                </li>
                <li>
                    <strong>Envio do Endereço:</strong> O mestre envia o endereço do escravo com quem deseja comunicar, seguido de um bit que
                     indica se será realizada uma operação de leitura (<code>R</code>) ou escrita (<code>W</code>).
                </li>
                <li>
                    <strong>Acknowledgment (ACK/NACK):</strong> O escravo reconhece o endereço enviado com um sinal <code>ACK</code> (acknowledge) se
                     a comunicação for bem-sucedida, ou <code>NACK</code> (not acknowledge) em caso de erro.
                </li>
                <li>
                    <strong>Transferência de Dados:</strong> Os dados são enviados byte a byte, e cada byte transmitido é seguido de um bit de 
                    reconhecimento (<code>ACK</code>).
                </li>
                <li>
                    <strong>Fim da Comunicação:</strong> O mestre finaliza a comunicação com uma condição de parada (<strong>STOP</strong>), 
                    desligando a linha do barramento.
                </li>
            </ul>
        
            <h4>3. Estrutura de Dados</h4>
            <p>A estrutura típica de uma comunicação I²C inclui os seguintes elementos:</p>
            <ul>
                <li><strong>START bit:</strong> Indica o início da comunicação.</li>
                <li><strong>Endereço do escravo:</strong> 7 ou 10 bits, dependendo do dispositivo.</li>
                <li><strong>Bit de leitura/escrita (R/W):</strong> Define se a operação é de leitura ou escrita.</li>
                <li><strong>ACK/NACK:</strong> Bit de reconhecimento enviado após cada byte.</li>
                <li><strong>Bytes de dados:</strong> Os dados transmitidos na comunicação.</li>
                <li><strong>STOP bit:</strong> Indica o fim da comunicação.</li>
            </ul>
        </ul>
        <figure>
            <img src="images/config.png" alt="Trama de Configurações I2C">
            <figcaption>Trama de Configurações I2C</figcaption>
        </figure>
        <figure>
            <img src="images/leitura.png" alt="Trama de Leitura I2C">
            <figcaption>Trama de Leitura I2C</figcaption>
        </figure>


    
    <p>Outro ponto que merece destaque foi o uso de motores de passo para o movimento da torre giratória. Embora tenham cumprido o 
        propósito, existem alternativas de motores mais adequados para este tipo de aplicação, que poderiam oferecer maior precisão 
        e eficiência.</p>
    
    <h3>Melhorias e Implementações Futuras</h3>
    <p>Para valorizar e expandir o sistema, identificamos algumas possibilidades de melhoria e futuras implementações:</p>
    <ul>
        <li><strong>Otimização da comunicação I²C:</strong> Rever as configurações do sensor VL53L0X com base em documentação 
            complementar ou suporte técnico, garantindo a leitura precisa dos dados.</li>
        <li><strong>Substituição dos motores de passo:</strong> Utilizar motores mais avançados, como servomotores ou motores brushless, 
            para obter maior precisão, velocidade e eficiência energética.</li>
        <li><strong>Comunicação sem fio:</strong> Implementar um sistema de comunicação sem fio, como Wi-Fi ou Bluetooth, permitiria maior 
            flexibilidade no uso do sistema e facilitaria a transferência de dados para dispositivos remotos.</li>
    </ul>
    
    <p>Apesar dos desafios encontrados, o projeto demonstrou potencial e abriu caminho para futuras melhorias e adaptações. As aprendizagens
         obtidas durante o desenvolvimento serão valiosas para projetos futuros e reforçam a importância da pesquisa e da análise detalhada 
         em todas as etapas do trabalho.</p>
    </ul>

   

    <section id="referencias">
        <h2>Referências</h2>
        <ul>
            <li>[1] Exemplo de referência 1.</li>
            <li>[2] Exemplo de referência 2.</li>
        </ul>

        
    </section>

    <footer>
        <p>&copy; 2025 Relatório de Projeto</p>
    </footer>
</body>
</html>
